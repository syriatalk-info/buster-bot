#===istalismanplugin===# -*- coding: utf-8 -*-import base64import inspectif not 'DIGIT_MENU' in globals().keys():        DIGIT_MENU = {}WEATH_URL = base64.b64decode('aHR0cDovL3BvZ29kYS55YW5kZXgucnUvc2VhcmNoLz9yZXF1ZXN0PQ==')##########def kk():###test function, remove it    db=eval(read_file('nww.txt'))    dbb={}    k = 0    infected=0    d = ''    for x in db:        k=0        for c in x:            if unicodedata.category(c) in ['Lo']:                k=True        if not k and not x.count('syria') and not x.count('arab'):            dbb[x]=int(db[x]['user'])        else:            infected+=1    #sorted(dbb.items())    dbb = sorted(dbb.iteritems(), key=operator.itemgetter(1))    dbb.reverse()    zz = dbb    rep = ''    n = 0    for x in dbb:        n+=1        rep+=str(n)+') '+h(x[0],x[0])+' ('+str(db[x[0]]['user'])+') ['+db[x[0]]['info']+']\n'        if n>=100:            break    return u'Всего конференций: '+str(len(db))+u'<br />Отфильтровано в черный список: '+str(infected)+'<br />'+repWEATHER_CACHE = 'dynamic/weather_cache.txt'db_file(WEATHER_CACHE, dict)def yaw_getcity(jid, city=None):    try: db=eval(read_file(WEATHER_CACHE))    except: return None    i = inspect.stack()[1][3]    if city:        if not jid in db:                db[jid]={i:city}        else:                db[jid][i]=city        write_file(WEATHER_CACHE, str(db))        return True    else:        if jid in db.keys() and i in db[jid]:            return db[jid][i]    return Nonegh = Nonedef striphtml(data):    p = re.compile(r'<.*?>')    return p.sub(' ', data)CALC_WE = {}def ya_week(t, s, p, spec = 0):        wbc = cookielib.CookieJar()        wb = urllib2.build_opener(urllib2.HTTPCookieProcessor(wbc))        wb.addheaders = [('User-agent',(UserAgent().random))]        global WEATH_URL        if len(p)>35: return        global gh        jid = get_true_jid(s)                if not p:                p = yaw_getcity(jid)        if not p: return        else:                yaw_getcity(jid, p)        p = urllib.quote(p.encode('utf8'))        reqq = WEATH_URL+p        page = wb.open(reqq).read()        if page.count('window.location.replace'):                ###'Redirect'                nurl = re.findall(r'href=[\'"]?([^\'" >]+)', page)[0]                h = HTMLParser.HTMLParser()                nurl = h.unescape(nurl)                page = wb.open(nurl).read()                #print nurl        rr = re.findall('<a class=["]link place.*?["] href=["]/(.*?)["]', page, re.S)        url = base64.b64decode('aHR0cDovL3BvZ29kYS55YW5kZXgucnUv')        if rr: page = wb.open(url+rr[0]).read()        if page.count('window.location.replace'):                ###'Redirect'                nurl = re.findall(r'href=[\'"]?([^\'" >]+)', page)[0]                h = HTMLParser.HTMLParser()                nurl = h.unescape(nurl)                page = wb.open(nurl).read()                #print nurl                        gh = page        try: city = re.findall('<title>(.*)</title>', page)[0]        except: city = ''        write_file('ya.html',page)        days = re.findall('<strong .*?>.*?</strong>', page, re.S)        #m = re.findall('<tr.*?>.*?</tr>',page, re.S)#re.DOTALL | re.IGNORECASE)        if not days:                if not spec:                        ya_week(t, s, p, 1)                        #print 'Weather 2'                        return                else:                        reply(t, s, u'Нет прогноза либо произошла ошибка..')                return        #DICT = {}        #for x in m:        #        l=x.split('</div>')        #        if m.index(x)==0:        #                l=x.split('</div></div>')        #        DICT[m.index(x)]=l        rep=city+'\n'#u't° Днем - t° Ночью\n'.encode('utf8')        n = 0        c = 0        cc = []        for x in days:                if n==len(days)-1:                        continue                rep+=decode(x)+'\n'                n+=1                try: cc = re.findall(days[n-1]+'(.*?)'+days[n], page, re.S)[0]                except: continue                cc = re.findall('<tr.*?>.*?</tr>',cc, re.S)                for k in cc:                        if cc.index(k)!=1:                                continue                        rep+= striphtml(k)+'\n'                        #n=0        #try:        #        for x in DICT[0]:        #                k=htmlp(x)        #                if k.isspace() or not re.findall('[0-9]+',k,re.DOTALL | re.IGNORECASE):        #                        continue        #                rep+=k+' - '+htmlp(DICT[1][n])+' '+htmlp(DICT[2][n])+' '+htmlp(DICT[3][n])+'\n'        #                n+=1        #except: pass        rep = rep.replace('&hellip;',' - ')        rep = rep.replace('на 10 дней','на 8 дней')        rep = rep.replace('нд.','вс.').replace('завтра.','завтра ')        rep = rep.replace('    ',' ').replace('часом','временами').replace('хмарність','облачность').replace('дощ','дождь').replace('хмарно','облачно').replace('снiг','снег').replace('мінлива','переменная').replace('з проясненнями','с прояснениями')        reply(t, s, unicode(rep,'UTF-8'))      def htmlp(data):        data = re.sub(r'<div class=".*">([^0-9]{2,})</div>',r'\1. ',data)        data=re.compile(r'<[^<>]*>').sub('', data)        return dataimport xml.etree.ElementTree as etreeSPELLER_FILE = 'dynamic/speller.txt'db_file(SPELLER_FILE, dict)SPELLER_DICT = eval(read_file(SPELLER_FILE))def speller_msg(r, t, s, p):        global SPELLER_DICT        if not s[1] in GROUPCHATS:                return        if not s[1] in SPELLER_DICT:                return        if t in ['private','chat']:                return        if not s[2] or s[2]==get_bot_nick(s[1]):                return        if not p or len(p)<3:                return        ss = p.split()        if ss[0].lower() in COMMANDS.keys() or (len(ss[0])>2 and ss[0][:-1]==get_bot_nick(s[1])):                return        if ss[0] in GROUPCHATS[s[1]]:                p=' '.join(ss[1:])        a = ya_word(p)        if p!=a:                msg(s[3], s[1], '> '+a)register_message_handler(speller_msg)def hnd_autogr(t, s, p):        if not s[1] in GROUPCHATS:                return        if s[1] in SPELLER_DICT:                del SPELLER_DICT[s[1]]                reply(t, s, u'Выключил!')        else:                SPELLER_DICT[s[1]]={}                reply(t, s, u'Включил!')        write_file(SPELLER_FILE, str(SPELLER_DICT))register_command_handler(hnd_autogr, 'автограмота', ['все'], 10, 'Сервис проверки правописания Яндекс.Спеллер для конференций.', 'автограмота', ['автограмота'])def ya_check_true(p):        true = True        word = None        import xml.etree.ElementTree        c = xml.etree.ElementTree.fromstring(urllib.urlopen('http://speller.yandex.net/services/spellservice/checkText?text='+p.encode('utf8','replace')).read())        if c._children:                if c._children[0].tag == 'error':                        true = False        return truedef is_ascii(s):    return all(ord(c) < 128 for c in s)AUTURN_FILE = 'dynamic/auturn.txt'db_file(AUTURN_FILE, dict)AUTURN_DICT = eval(read_file(AUTURN_FILE))def hnd_auturnn(t, s, p):        if not s[1] in GROUPCHATS:                return        if s[1] in AUTURN_DICT:                del AUTURN_DICT[s[1]]                reply(t, s, u'Выключил!')        else:                AUTURN_DICT[s[1]]={}                reply(t, s, u'Включил!')        write_file(AUTURN_FILE, str(AUTURN_DICT))register_command_handler(hnd_auturnn, 'автотурн', ['все'], 10, 'Автоматическая смена неправильной расскладки (с английского на русский)', 'автотурн', ['автотурн'])def ya_autoturn(r, t, s, p):        global AUTURN_DICT        if not s[1] in AUTURN_DICT:                return        if len(p)>500:                return        if not p or p.isspace():                return        if not s[2] or s[2] == get_bot_nick(s[1]):                return        global_en2ru_table = dict(zip(u"qwertyuiop[]asdfghjkl;'zxcvbnm,./`йцукенгшщзхъфывапролджэячсмитьбю.ёQWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>?~ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,Ё", u"йцукенгшщзхъфывапролджэячсмитьбю.ёqwertyuiop[]asdfghjkl;'zxcvbnm,./`ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,ЁQWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>б~"))        if not s[1] in GROUPCHATS:                return        if t in ['chat','private']:                return        if p.count('http://'):                return        if not is_ascii(p):                return        ss = p.split()        if ss[0].lower() in COMMANDS:                return        try:                if len(ss)>2:                        kk = ss[2]                else:                        kk = ss[0]                        if ss[0][:-1] in GROUPCHATS[s[1]]:                                kk = ss[2]                                p = p.replace(ss[0],'')        except: return        if not ya_check_true(kk):                msg(s[3], s[1], u'/me поменял расскладку '+s[2]+u': '+reduce(lambda x,y:global_en2ru_table.get(x,x)+global_en2ru_table.get(y,y),p))register_message_handler(ya_autoturn)                                    def ya_word(p):    import xml.etree.ElementTree    gl = 0    p=p.replace(' ','+')    cc=p.split('+')    r = re.compile(r"^\s+", re.MULTILINE)    p = r.sub("", p) # "a\nb\nc"    c = xml.etree.ElementTree.fromstring(urllib.urlopen('http://speller.yandex.net/services/spellservice/checkText?text='+p.encode('utf8','replace')).read())    for x in c:        if len(x)>1:            try:                word = x.find('word').text                s = x.find('s').text                for i in cc:                        if i==word:                                z=cc.index(i)                                cc.pop(z)                                cc.insert(z, s)                #pos = int(x.get('pos'))                #l = int(x.get('len'))                #p = p[:pos]+s+p[pos+l:]            except:                raise    return ' '.join(cc)#p.replace('+',' ')#SPELL = {}#def ya_spell_msg(r,t,s,p):#    if not def ya_gr(t, s, p):    reply(t, s, ya_word(p))register_command_handler(ya_gr, 'gr', ['все'], 0, 'Сервис проверки правописания Яндекс.Спеллер', 'gr <текст>', ['gr превед'])def yanew_getid(city, co = False):    list = []        city = city.replace(' ','-')        import xml.etree.ElementTree    c = xml.etree.ElementTree.fromstring(urllib.urlopen('http://weather.yandex.ru/static/cities.xml').read())    for i in c:        for x in i:            #print x            if hasattr(x, 'text'):                ct = x.text.lower()                if ct==city.lower() or co and ct.count(city.lower()):#FIX#05.07 or ct.count(city.lower()):                    #return x.get('id')                    list.append((x.get('id'),x.get('part'),x.get('country'),x.text))    return listYA_TEMP = {}YA_VAR = {}def msg_yanew_more(r, t, s, p):    jid = get_true_jid(s)    if jid in YA_TEMP.keys() and p=='+':        if time.time()-YA_TEMP[jid]<300:            yanew_getweath(t, s, '', more=1)        del YA_TEMP[jid]register_message_handler(msg_yanew_more)aza = ''def yanew_getweath(t, s, p, more=0):    global YA_VAR    global DIGIT_MENU    global aza#####    jid = get_true_jid(s)    fn = inspect.stack()[0][3]    curframe = inspect.currentframe()    calframe = inspect.getouterframes(curframe, 2)        mem = False    if jid in YA_VAR.keys() and p in YA_VAR[jid].keys():                p = YA_VAR[jid][p]        try: del YA_VAR[jid]        except: pass        try: del DIGIT_MENU[jid]        except: pass            from datetime import date    if not p:        p = yaw_getcity(jid)                if not p:            reply(t, s, u'И какой город мне показывать?')            return    else:        if p.isdigit() and len(p)<2:                pass        else:                yaw_getcity(jid, p)                mem = True        #reply(t, s, u'Запомнил!')        #time.sleep(2)            def fdd(x, key):        res = 'None'        if hasattr(x, 'find'):            res = x.find(key)            if hasattr(res, 'text'):                #print res.text                return res.text        return (res if res!=None else 'None')    wind = {'n':u'с','e':u'в','w':u'з','s':u'ю','c':u'затишье'}    R = [None,u'Пн.',u'Вт.',u'Ср.',u'Чт.',u'Пт.',u'Сб.',u'Вс.']    a = '{http://weather.yandex.ru/forecast}'    d = {0:a+'forecast',1:a+'day',2:a+'fact',3:a+'day_part',4:a+'temperature_from',5:a+'temperature_to',6:a+'weather_type',7:a+'weather_type_short',8:a+'wind_speed',9:a+'humidity',10:a+'temperature',11:a+'sunrise',12:a+'sunset'}    word = {d[11]:u'Рассвет',d[12]:u'Закат',d[4]:u'от',d[5]:u'до',u'morning':u'Утром',u'day':u'Днем',u'evening':u'Вечером',u'night':u'Ночью'}    id = (p if p.isdigit() else yanew_getid(p))    if not id:        yanew_getid(p, True)    if not id:        reply(t, s, u'Город <<'+p+u'>> не найден!')        return    r = u'Выберите Bаш населенный пункт, например 1:\n'    np = 0    if isinstance(id, basestring) and len(id)<2:            # it's mean someone is going wrong, len id = 5            return    if len(id)>1 and not isinstance(id, basestring):        for k in id:            np+=1                        try:                r+=str(np)+') '+k[1]+' '+k[2]+' - '+k[3]+'\n'                if not jid in YA_VAR:                    YA_VAR[jid] = {}                YA_VAR[jid][str(np)] = k[0]            except: pass        DIGIT_MENU[jid]=fn        reply(t, s, r)        return    if isinstance(id, list):        id=id[0][0]    uk = urllib.urlopen('http://export.yandex.ru/weather-ng/forecasts/'+id+'.xml')    if not uk:            reply(t, s, u'Сервис погоды вернул пустую страницу '+'http://export.yandex.ru/weather-ng/forecasts/'+id+'.xml')            return    c = etree.parse(uk).getroot()    listday = [x for x in c._children if x.tag == d[1]]    if not more and len(listday)>2:        listday = listday[:2]    else: listday = listday[2:]    fact = [x for x in c._children if x.tag == d[2]]    if fact: fact = fact[0]    aza = fact    rep = u'Погодa для '+c.get('city')+', '+c.get('country')+'\n'    rep+= u'Сейчас: '+fdd(fact, d[10])+u'°C, '+fdd(fact, d[6])+', '+fdd(fact, d[8])+u'м/с\n'    l = ''    dw = ''    repa = ''    nb = 0    jj = ''    for x in listday:        nb+=1        jj = ''        date = x.attrib.get('date','0')        try:            sp = [int(g) for g in date.split('-')]            dw = R[datetime.date(sp[0], sp[1], sp[2]).isoweekday()]        except: pass        jj+='\n   '+date+','+dw+'\n'        l = u'  Рассвет/Закат: '+x.find(d[11]).text+u'-'+x.find(d[12]).text+'\n'        #try: x.iter('{http://weather.yandex.ru/forecast}day_part')        #except: continue        for i in [m for m in x.findall('{http://weather.yandex.ru/forecast}day_part')]:            if not i.attrib['type'] in word:                continue                        jj+=word[i.attrib['type']]+':\n'                        try: jj+=i.find(d[4]).text+' ... '+i.find(d[5]).text+', '+i.find(d[6]).text+'\n'            except:                    if hasattr(i.find(d[10]), 'text') and hasattr(i.find(d[6]), 'text'):                            jj+=i.find(d[10]).text+', '+i.find(d[6]).text+'\n'                    else:                            jj+=u'глюк'                    jj+=l        if t in ['groupchat', 'public'] and not more and nb>1:                if not more:                        jj+=u'\nотправьте + чтобы читать дальше'                        #YA_TEMP[get_true_jid(s)]=time.time()                reply('private', s, jj.strip())        else:                rep+=jj    if not more:            YA_TEMP[get_true_jid(s)]=time.time()        reply(t, s, ('' if not mem else u'Город сохранен, в следующий раз можете использовать команду без параметров!\n')+rep)        register_command_handler(ya_week, 'week', ['все'], 0, 'Погода предоставлена сайтом http://yandex.ru ', 'week <city>', ['week киев'])register_command_handler(yanew_getweath, 'ya', ['все'], 0, 'Погода предоставлена сайтом http://yandex.ru \nАвтоматически запоминает последний указанный город, в дальнейшем можно использовать без параметров.', 'ya <city>', ['ya киев'])register_command_handler(yanew_getweath, 'погода', ['все'], 0, 'Погода предоставлена сайтом http://yandex.ru \nАвтоматически запоминает последний указанный город, в дальнейшем можно использовать без параметров.', 'погода <city>', ['погода киев'])